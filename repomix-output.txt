This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-18T16:22:59.773Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
public/
  index.html
src/
  bryHashMap.cpp
  bryHashMap.h
  main.cpp
  RBTree.cpp
  TileDownloader.cpp
  TileDownloader.h
.gitignore
CMakeLists.txt
README.md

================================================================
Repository Files
================================================================

================
File: public/index.html
================
<!DOCTYPE html>
<html>
<head>
    <title>Gainesville Traffic Heatmap</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
</head>
<body>
    <div id="root"></div>
</body>
</html>

================
File: src/bryHashMap.cpp
================
#include <iostream>
#include <string>
#include "bryHashMap.h"

using namespace std;

// constructor for the hashmap
bHash::bHash() {

    for(int i = 0; i < tableSize; i++)
    {
        hashTable[i] = new crashData;
        hashTable[i]->caseNumber = 0;
        hashTable[i]->latitude = 0;
        hashTable[i]->longitude = 0;
        hashTable[i]->totalVehicle = 0;
        hashTable[i]->next = nullptr;
    }
}

// Shows number of items in a bucket
int bHash::NumberOfItemsInBucket(int bucket) {
    int count = 0;

    if(hashTable[bucket]->caseNumber == 0)
    {
        return count;
    }
    else
    {
        count++;
        crashData* ptr = hashTable[bucket];
        while(ptr->next != nullptr)
        {
            count++;
            ptr = ptr->next;
        }
    }
    return count;
}

// Show total number of elements in hashMap
int bHash::GetTotalItems() {
    int totalItems = 0;
    for (int i = 0; i < tableSize; i++) {
        crashData* ptr = hashTable[i];
        while (ptr != nullptr && ptr->caseNumber != 0) {
            totalItems++;
            ptr = ptr->next;
        }
    }
    return totalItems;
}

// Adds item into the hashmap
void bHash::AddItem(int caseNumber, double latitude, double longitude, int totalVehicle) {

    int bucket = Hash(caseNumber);

    if(hashTable[bucket]->caseNumber == 0)
    {
        hashTable[bucket]->caseNumber = caseNumber;
        hashTable[bucket]->latitude = latitude;
        hashTable[bucket]->longitude = longitude;
        hashTable[bucket]->totalVehicle = totalVehicle;
    }
    else
    {
        crashData* ptr = hashTable[bucket];
        crashData* n = new crashData;
        n->caseNumber = caseNumber;
        n->latitude = latitude;
        n->longitude = longitude;
        n->totalVehicle = totalVehicle;
        n->next = nullptr;
        while(ptr->next != nullptr)
        {
            ptr = ptr->next;

        }
        ptr->next = n;
    }
}

// Function to print table and values
void bHash::PrintTable() {

    // number of elements in bucket, and prints table
    int number;
    for (int i = 0; i < tableSize; i++)
    {
        number = NumberOfItemsInBucket(i);
        cout << "------------------------" << endl;
        cout << "Bucket =  " << i << endl;
        cout << hashTable[i]->caseNumber << endl;
        cout << hashTable[i]->latitude << endl;
        cout << hashTable[i]->longitude << endl;
        cout << hashTable[i]->totalVehicle << endl;
        cout << "# of items = " << number << endl;
        cout << "------------------------" << endl;
    }
}

// Function for hashing
int bHash::Hash(int key) {
    // Hash function using modulo operation
    return key % 210000000 % tableSize;
}

================
File: src/bryHashMap.h
================
#pragma once
#include <iostream>
#include <string>

using namespace std;

class bHash {
public:
    static const int tableSize = 40;

    struct crashData {
        int caseNumber;
        double longitude;
        double latitude;
        int totalVehicle;
        crashData* next;
    };

    crashData* hashTable[tableSize];
    bHash();
    int Hash(int key);
    void AddItem(int caseNumber, double latitude, double longitude, int totalPeople);
    int NumberOfItemsInBucket(int bucket);
    void PrintTable();
    int GetTotalItems();
};

================
File: src/main.cpp
================
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>
#include <stdexcept>
#include <SFML/Graphics.hpp>
#include "bryHashMap.h"
#include "RBTree.cpp"
#include "TileDownloader.h"

using namespace std;

struct crashData {
   int caseNumber;
   double latitude;
   double longitude; 
   int totalVehicle;
   string crashDay;
};

struct uniqueCoords {
   int caseNumber;
   double latitude;
   double longitude;
   int totalVehicleSum;
   uniqueCoords(int caseNum, double lat, double lon, int sum) : 
       caseNumber(caseNum), latitude(lat), longitude(lon), totalVehicleSum(sum) {}
};

vector<string> split(const string& line, char delim) {
   vector<string> tokens;
   istringstream tokenStream(line);
   string token;
   while(getline(tokenStream, token, delim)) {
       tokens.push_back(token);
   }
   return tokens;
}

void parseCSV(const string& filename, vector<crashData>& crashdata, bHash& crashDataMap, RBTree& RbtreeData) {
   ifstream file(filename);
   if (!file.is_open()) {
       cerr << "Failed to open " << filename << endl;
       exit(EXIT_FAILURE);
   }
   
   string line;
   getline(file, line);

   vector<uniqueCoords> uniqueC;

   while (getline(file, line)) {
       vector<string> tokens = split(line, ',');
       if (tokens.size() >= 24) {
           crashData data;
           try {
               data.caseNumber = stoi(tokens[0]);
               data.latitude = stod(tokens[23]);
               data.longitude = stod(tokens[22]);
               data.totalVehicle = stoi(tokens[15]);
               data.crashDay = tokens[5];

               crashdata.push_back(data);
               auto it = find_if(uniqueC.begin(), uniqueC.end(), [&](const uniqueCoords& uc){
                   return uc.latitude == data.latitude && uc.longitude == data.longitude;
               });

               if(it != uniqueC.end()) {
                   it->totalVehicleSum += data.totalVehicle;
               } else {
                   uniqueC.emplace_back(data.caseNumber, data.latitude, data.longitude, data.totalVehicle);
               }
           } catch (const exception& e) {
               continue;
           }
       }
   }

   for(auto a: uniqueC) {
       crashDataMap.AddItem(a.caseNumber, a.latitude, a.longitude, a.totalVehicleSum);
       RbtreeData.insert(a.caseNumber, a.latitude, a.longitude, a.totalVehicleSum);
   }
}

void createMapVisualization(bHash& crashDataMap) {
   sf::RenderWindow window(sf::VideoMode(1200, 800), "Gainesville Traffic Crashes");
   
   // Background color for map
   sf::RectangleShape background(sf::Vector2f(1200, 800));
   background.setFillColor(sf::Color(240, 240, 240));
   
   // Constants for coordinate transformation
   const double MIN_LAT = 29.5734;
   const double MAX_LAT = 29.75;
   const double MIN_LON = -82.5;
   const double MAX_LON = -82.1;

   // For crash intensity colors
   const int MAX_INTENSITY = 255;
   
   while (window.isOpen()) {
       sf::Event event;
       while (window.pollEvent(event)) {
           if (event.type == sf::Event::Closed)
               window.close();
       }

       window.clear(sf::Color::White);
       window.draw(background);

       for(int i = 0; i < crashDataMap.tableSize; i++) {
           auto* ptr = crashDataMap.hashTable[i];
           while(ptr != nullptr && ptr->caseNumber != 0) {
               float x = (ptr->longitude - MIN_LON) / (MAX_LON - MIN_LON) * window.getSize().x;
               float y = (MAX_LAT - ptr->latitude) / (MAX_LAT - MIN_LAT) * window.getSize().y;
               
               // Scale point size based on vehicle count
               float radius = log(ptr->totalVehicle + 2) * 3;
               
               sf::CircleShape point(radius);
               point.setPosition(x - radius, y - radius);
               
               // Color based on vehicle count
               int intensity = std::min(MAX_INTENSITY, 
                   (int)(ptr->totalVehicle * 25));
               point.setFillColor(sf::Color(intensity, 0, MAX_INTENSITY - intensity, 180));
               
               window.draw(point);
               ptr = ptr->next;
           }
       }

       window.display();
   }
}

void createRBMapVisualization(RBTree& RbtreeData) {
   sf::RenderWindow window(sf::VideoMode(1200, 800), "Gainesville Traffic Crashes (RB Tree)");
   
   // Background color for map
   sf::RectangleShape background(sf::Vector2f(1200, 800));
   background.setFillColor(sf::Color(240, 240, 240));
   
   // Constants for coordinate transformation
   const double MIN_LAT = 29.5734;
   const double MAX_LAT = 29.75;
   const double MIN_LON = -82.5;
   const double MAX_LON = -82.1;

   // Get data from RB Tree
   vector<double> latitudeVec;
   vector<double> longitudeVec;
   vector<double> totalVehiclesVec;
   RbtreeData.inorder(latitudeVec, longitudeVec, totalVehiclesVec);
   
   while (window.isOpen()) {
       sf::Event event;
       while (window.pollEvent(event)) {
           if (event.type == sf::Event::Closed)
               window.close();
       }

       window.clear(sf::Color::White);
       window.draw(background);

       // Draw points for each crash location
       for(size_t i = 0; i < latitudeVec.size(); i++) {
           float x = (longitudeVec[i] - MIN_LON) / (MAX_LON - MIN_LON) * window.getSize().x;
           float y = (MAX_LAT - latitudeVec[i]) / (MAX_LAT - MIN_LAT) * window.getSize().y;
           
           // Scale point size based on vehicle count
           float radius = log(totalVehiclesVec[i] + 2) * 3;
           
           sf::CircleShape point(radius);
           point.setPosition(x - radius, y - radius);
           
           // Color based on vehicle count
           int intensity = std::min(255, (int)(totalVehiclesVec[i] * 25));
           point.setFillColor(sf::Color(intensity, 0, 255 - intensity, 180));
           
           window.draw(point);
       }

       window.display();
   }
}

void menu(bHash& crashDataMap, RBTree& RbtreeData) {
   int option;

   while (true) {
       cout << "Choose an option: " << endl;
       cout << "Option 1: Hash Map Visualization" << endl;
       cout << "Option 2: Red and Black Tree Visualization" << endl;
       cout << "Enter option (1 or 2): " << endl;

       if (!(cin >> option) || (option != 1 && option != 2)) {
           cout << "Invalid input. Please enter 1 or 2." << endl;
           cin.clear();
           cin.ignore(numeric_limits<streamsize>::max(), '\n');
       } else {
           break;
       }
   }

   if (option == 1) {
       cout << "Generating Map Using Hash Map..." << endl;
       createMapVisualization(crashDataMap);
   } else if (option == 2) {
       cout << "Generating Map Using Red and Black Tree..." << endl;
       createRBMapVisualization(RbtreeData);
   }
}

int main() {
     TileDownloader downloader;
    if (!downloader.downloadTiles() || !downloader.createMergedMap()) {
        std::cerr << "Failed to setup map" << std::endl;
    }
   string filename = "Traffic_Crashes.csv";
   vector<crashData> crashdata;
   bHash crashDataMap;
   RBTree RbtreeData;
   parseCSV(filename, crashdata, crashDataMap, RbtreeData);
   menu(crashDataMap, RbtreeData);
   
   return 0;
}

================
File: src/RBTree.cpp
================
#include <iostream>
#include <tuple>
#include <vector>


using namespace std;

struct Node {
    int key; // holds the key
    tuple<double, double, int> values;
    Node *parent; // pointer to the parent
    Node *left; // pointer to left child
    Node *right; // pointer to right child
    int color; // 1 -> Red, 0 -> Black
};

typedef Node *NodePtr;

// class RBTree implements the operations in Red Black Tree
class RBTree {
private:
    NodePtr root;
    NodePtr TNULL;

    void initializeNULLNode(NodePtr node, NodePtr parent) {
        node->key = 0;
        node->parent = parent;
        node->left = nullptr;
        node->right = nullptr;
        node->color = 0;
    }

    void inOrderHelper(NodePtr node, vector<double>& latitudeVec, vector<double>& longitudeVec, vector<double>& totalVehiclesVec) {
        if (node != TNULL) {
            inOrderHelper(node->left, latitudeVec, longitudeVec, totalVehiclesVec);

            auto values = node->values;
            double latitude = get<0>(values);
            double longitude = get<1>(values);
            double totalVehicles = get<2>(values);

            latitudeVec.push_back(latitude);
            longitudeVec.push_back(longitude);
            totalVehiclesVec.push_back(totalVehicles);

            inOrderHelper(node->right, latitudeVec, longitudeVec, totalVehiclesVec);
        }
    }

    NodePtr searchTreeHelper(NodePtr node, int key) {
        if (node == TNULL || key == node->key) {
            return node;
        }

        if (key < node->key) {
            return searchTreeHelper(node->left, key);
        }
        return searchTreeHelper(node->right, key);
    }

    // fix the red-black tree
    void fixInsert(NodePtr k){
        NodePtr u;
        while (k->parent->color == 1) {
            if (k->parent == k->parent->parent->right) {
                u = k->parent->parent->left; // uncle
                if (u->color == 1) {
                    // case 3.1
                    u->color = 0;
                    k->parent->color = 0;
                    k->parent->parent->color = 1;
                    k = k->parent->parent;
                } else {
                    if (k == k->parent->left) {
                        // case 3.2.2
                        k = k->parent;
                        rightRotate(k);
                    }
                    // case 3.2.1
                    k->parent->color = 0;
                    k->parent->parent->color = 1;
                    leftRotate(k->parent->parent);
                }
            } else {
                u = k->parent->parent->right; // uncle

                if (u->color == 1) {
                    // mirror case 3.1
                    u->color = 0;
                    k->parent->color = 0;
                    k->parent->parent->color = 1;
                    k = k->parent->parent;
                } else {
                    if (k == k->parent->right) {
                        // mirror case 3.2.2
                        k = k->parent;
                        leftRotate(k);
                    }
                    // mirror case 3.2.1
                    k->parent->color = 0;
                    k->parent->parent->color = 1;
                    rightRotate(k->parent->parent);
                }
            }
            if (k == root) {
                break;
            }
        }
        root->color = 0;
    }

public:
    //constructor
    RBTree() {
        TNULL = new Node;
        TNULL->color = 0;
        TNULL->left = nullptr;
        TNULL->right = nullptr;
        root = TNULL;
    }

    //inorder traversal
    void inorder(vector<double>& latitudeVec, vector<double>& longitudeVec, vector<double>& totalVehiclesVec) {
        inOrderHelper(this->root, latitudeVec, longitudeVec, totalVehiclesVec);
    }

    // search the tree for the key k
    // and return the corresponding node
    NodePtr searchTree(int k) {
        return searchTreeHelper(this->root, k);
    }

    // rotate left at node x
    void leftRotate(NodePtr x) {
        NodePtr y = x->right;
        x->right = y->left;
        if (y->left != TNULL) {
            y->left->parent = x;
        }
        y->parent = x->parent;
        if (x->parent == nullptr) {
            this->root = y;
        } else if (x == x->parent->left) {
            x->parent->left = y;
        } else {
            x->parent->right = y;
        }
        y->left = x;
        x->parent = y;
    }

    // rotate right at node x
    void rightRotate(NodePtr x) {
        NodePtr y = x->left;
        x->left = y->right;
        if (y->right != TNULL) {
            y->right->parent = x;
        }
        y->parent = x->parent;
        if (x->parent == nullptr) {
            this->root = y;
        } else if (x == x->parent->right) {
            x->parent->right = y;
        } else {
            x->parent->left = y;
        }
        y->right = x;
        x->parent = y;
    }

    // insert the key to the tree in its appropriate position
    // and fix the tree
    void insert(int key, double latitude, double longtitude, int value3) {
        // Ordinary Binary Search Insertion
        NodePtr node = new Node;
        node->parent = nullptr;
        node->key = key;
        node->values = make_tuple(latitude, longtitude, value3);
        node->left = TNULL;
        node->right = TNULL;
        node->color = 1; // new node must be red

        NodePtr y = nullptr;
        NodePtr x = this->root;

        while (x != TNULL) {
            y = x;
            if (node->key < x->key) {
                x = x->left;
            } else {
                x = x->right;
            }
        }

        // y is parent of x
        node->parent = y;
        if (y == nullptr) {
            root = node;
        } else if (node->key < y->key) {
            y->left = node;
        } else {
            y->right = node;
        }

        // if new node is a root node, simply return
        if (node->parent == nullptr){
            node->color = 0;
            return;
        }

        // if the grandparent is null, simply return
        if (node->parent->parent == nullptr) {
            return;
        }

        // Fix the tree
        fixInsert(node);
    }
};

================
File: src/TileDownloader.cpp
================
#include "TileDownloader.h"

bool setupMapResources() {
   TileDownloader downloader;
   
   std::cout << "Downloading map tiles..." << std::endl;
   if (!downloader.downloadTiles()) {
       std::cerr << "Failed to download map tiles" << std::endl;
       return false;
   }
   
   std::cout << "Creating merged map..." << std::endl;
   if (!downloader.createMergedMap()) {
       std::cerr << "Failed to create merged map" << std::endl;
       return false;
   }
   
   return true;
}

// This function should be called before visualization
void initializeMap() {
   if (!setupMapResources()) {
       std::cerr << "Map initialization failed" << std::endl;
       exit(1);
   }
   std::cout << "Map initialization complete" << std::endl;
}

================
File: src/TileDownloader.h
================
#pragma once
#include <SFML/Graphics.hpp>
#include <curl/curl.h>
#include <cmath>
#include <sstream>
#include <fstream>
#include <string>
#include <iostream>
#include <sys/stat.h>

class TileDownloader {
private:
   const double MIN_LAT = 29.5734;
   const double MAX_LAT = 29.75;
   const double MIN_LON = -82.5;
   const double MAX_LON = -82.1;
   const int ZOOM = 12;
   const int TILE_SIZE = 256;

   static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
       ((std::string*)userp)->append((char*)contents, size * nmemb);
       return size * nmemb;
   }

   bool directoryExists(const std::string& path) {
       struct stat info;
       return stat(path.c_str(), &info) == 0 && (info.st_mode & S_IFDIR);
   }

   bool fileExists(const std::string& filename) {
       struct stat info;
       return stat(filename.c_str(), &info) == 0;
   }

   bool createDirectory(const std::string& path) {
       #ifdef _WIN32
           return _mkdir(path.c_str()) == 0;
       #else
           return mkdir(path.c_str(), 0777) == 0;
       #endif
   }

   int long2tilex(double lon, int z) {
       return static_cast<int>(floor((lon + 180.0) / 360.0 * std::pow(2.0, z)));
   }
   
   int lat2tiley(double lat, int z) {
       double latrad = lat * M_PI/180.0;
       return static_cast<int>(floor((1.0 - asinh(tan(latrad)) / M_PI) / 2.0 * std::pow(2.0, z)));
   }

   bool downloadTile(CURL* curl, int x, int y, const std::string& filename) {
       std::stringstream url;
       url << "https://tile.openstreetmap.org/" << ZOOM << "/" << x << "/" << y << ".png";
       
       std::string readBuffer;
       curl_easy_setopt(curl, CURLOPT_URL, url.str().c_str());
       curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
       curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
       curl_easy_setopt(curl, CURLOPT_USERAGENT, "OSM Tile Downloader/1.0");
       
       CURLcode res = curl_easy_perform(curl);
       if (res != CURLE_OK) {
           std::cerr << "Failed to download tile: " << curl_easy_strerror(res) << std::endl;
           return false;
       }

       std::ofstream outFile(filename, std::ios::binary);
       if (!outFile) {
           std::cerr << "Failed to create file: " << filename << std::endl;
           return false;
       }
       outFile.write(readBuffer.c_str(), readBuffer.size());
       return true;
   }

public:
   bool downloadTiles() {
       int minX = long2tilex(MIN_LON, ZOOM);
       int maxX = long2tilex(MAX_LON, ZOOM);
       int minY = lat2tiley(MAX_LAT, ZOOM);
       int maxY = lat2tiley(MIN_LAT, ZOOM);

       CURL* curl = curl_easy_init();
       if (!curl) {
           std::cerr << "Failed to initialize CURL" << std::endl;
           return false;
       }

       try {
           if (!directoryExists("tiles")) {
               if (!createDirectory("tiles")) {
                   std::cerr << "Failed to create tiles directory" << std::endl;
                   curl_easy_cleanup(curl);
                   return false;
               }
           }
           
           for(int x = minX; x <= maxX; x++) {
               for(int y = minY; y <= maxY; y++) {
                   std::string filename = "tiles/" + std::to_string(x) + "_" + std::to_string(y) + ".png";
                   
                   if (!fileExists(filename)) {
                       if (!downloadTile(curl, x, y, filename)) {
                           curl_easy_cleanup(curl);
                           return false;
                       }
                       sf::sleep(sf::milliseconds(100));  // Rate limiting
                   }
               }
           }

           curl_easy_cleanup(curl);
           return true;
       }
       catch (const std::exception& e) {
           std::cerr << "Error downloading tiles: " << e.what() << std::endl;
           curl_easy_cleanup(curl);
           return false;
       }
   }
   
   bool createMergedMap() {
       try {
           int minX = long2tilex(MIN_LON, ZOOM);
           int maxX = long2tilex(MAX_LON, ZOOM);
           int minY = lat2tiley(MAX_LAT, ZOOM);
           int maxY = lat2tiley(MIN_LAT, ZOOM);
           
           int width = (maxX - minX + 1) * TILE_SIZE;
           int height = (maxY - minY + 1) * TILE_SIZE;
           
           sf::RenderTexture mapTexture;
           if (!mapTexture.create(width, height)) {
               std::cerr << "Failed to create render texture" << std::endl;
               return false;
           }
           
           mapTexture.clear(sf::Color::White);
           
           for(int x = minX; x <= maxX; x++) {
               for(int y = minY; y <= maxY; y++) {
                   std::string filename = "tiles/" + std::to_string(x) + "_" + std::to_string(y) + ".png";
                   
                   sf::Texture tileTexture;
                   if(tileTexture.loadFromFile(filename)) {
                       sf::Sprite tileSprite(tileTexture);
                       tileSprite.setPosition(
                           static_cast<float>((x - minX) * TILE_SIZE),
                           static_cast<float>((y - minY) * TILE_SIZE)
                       );
                       mapTexture.draw(tileSprite);
                   }
               }
           }
           
           mapTexture.display();
           return mapTexture.getTexture().copyToImage().saveToFile("gainesville_map.png");
       }
       catch (const std::exception& e) {
           std::cerr << "Error creating merged map: " << e.what() << std::endl;
           return false;
       }
   }
};

================
File: .gitignore
================
# Project exclude paths
/cmake-build-debug/

================
File: CMakeLists.txt
================
cmake_minimum_required(VERSION 3.14)
project(DSA_GNV_Traffic_Heat_Map)
set(CMAKE_CXX_STANDARD 14)

find_package(SFML 2.5 COMPONENTS graphics window system REQUIRED)
find_package(CURL REQUIRED)

set(EXECUTABLE_NAME HeatMap)

add_executable(${EXECUTABLE_NAME}
    src/main.cpp
    src/bryHashMap.cpp
    src/RBTree.cpp
)

target_link_libraries(${EXECUTABLE_NAME} 
    sfml-graphics 
    sfml-window 
    sfml-system
    ${CURL_LIBRARIES}
)

target_include_directories(${EXECUTABLE_NAME} PRIVATE ${CURL_INCLUDE_DIRS})
configure_file(${CMAKE_SOURCE_DIR}/Traffic_Crashes.csv ${CMAKE_BINARY_DIR}/Traffic_Crashes.csv COPYONLY)

================
File: README.md
================
# Gainesville HeatMap

Project that creates a heat map of Gainesville that displays car crash locations at the University of Florida and the surronding areas. This implementation allows the user to select between a B-Tree or HashMap data strucutre to compare the time it takes for each structure to generate the map.

## CMake

This project utilizes CMake as its build system, simplifying the build process across different platforms. CMake automates the detection and configuration of various dependencies and compiler options, ensuring that the project can be built with minimal setup!

### Getting it running!

Before building the project, you need to ensure that all dependencies are installed:

- **CMake**: Install the latest version of CMake (at least 3.14). You can download it from [CMake's official website](https://cmake.org/download/).
- **Compiler**: Ensure you have a C++14 compliant compiler installed. For macOS, you can use Clang that comes with Xcode. On Windows, you could use MinGW or Visual Studio.
- **Matplot++**: The project's CMake configuration is set to fetch and build this library automatically. If for any reason you need to install it manually, follow the instructions from the [Matplot++ GitHub repository](https://github.com/alandefreitas/matplotplusplus).

Once those dependencies are wrapped up, and you have cloned the repo, we can move on to buiding the heatmap program.


1. Navigate to the project's root directory in the terminal.
2. Navigate to the build directory, then run "cmake ..", This will generate the build files in the "build" directory.
3. Run the terminal command "make" for the makefile in the "build" directory that was generated to compile the code.
4. The executable is now within the "build" directory!
5. Run the terminal command "./HeatMap" in the build directory to begin the application and generate your heatmap.


## Usage

After building the project, run the executable generated in the `build` directory. The application prompts the user to choose between using a B-Tree or HashMap. Based on the selection, the program processes the data and generates a heat map visualization.
